<!doctype html>
<html class="lazyload">
    <head>
        <title>index Â· StrictJson</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
                <link rel="icon" type="image/png" href="https://sburba.github.io/strict-json/icon.png">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Share:400|Jaldi:400,700|Fira+Mono:400,700">
        <link rel="stylesheet" href="https://sburba.github.io/strict-json/assets/base.css">
        <link rel="stylesheet" href="https://sburba.github.io/strict-json/assets/lindoc.css">
                <script>
            // Parent Elements - e.P("body") - https://gist.github.com/moqmar/0995cf6595201f7a062fb173cb4ab938
            (function(E){E.matches||(E.matches=E.matchesSelector||E.msMatchesSelector||E.webkitMatchesSelector)})(Element.prototype)
            Element.prototype.P=function(s){var e=this
            if(!s||typeof s=="number")for(var i=0;i<(s||1);i++)e=e?e.parentElement:e
            else if(typeof s=="string")while(e&&!e.matches(s))e=e.parentElement
            else while(e&&e!=s)e=e.parentElement
            return e}
        </script>
    </head>
    <body>
        <header>
            <h1>
                <a href="https://sburba.github.io/strict-json/">StrictJson</a>
            </h1>
            <nav class="breadcrumbs">
                
            </nav>
        </header>

        <main>
            <aside class="toc"><ul></ul></aside>
            <article>

<!-- CONTENT START -->
<p>StrictJson turns JSON into your plain old PHP classes</p>
<h1 id="why-use-strictjson">Why use StrictJson?</h1>
<p>Given this JSON</p>
<pre><code class="language-json">{
  "name": "Joe User",
  "age": 4,
  "address": {
    "street": "1234 Fake St.",
    "zip_code": "12345"
  }
}</code></pre>
<p>StrictJson turns this code:</p>
<pre><code class="language-php">&lt;?php declare(strict_types=1);
use Burba\StrictJson\Fixtures\Docs\Address;
use Burba\StrictJson\Fixtures\Docs\User;

$decoded_json = json_decode($json, true);
if (!is_array($decoded_json)) {
    throw new RuntimeException('Invalid JSON');
}

$name = $decoded_json['name'] ?? null;
$age = $decoded_json['age'] ?? null;
$street = $decoded_json['address']['street'] ?? null;
$zip_code = $decoded_json['address']['zip_code'] ?? null;

if (!is_string($name) || !is_int($age) || !is_string($street) || !is_string($zip_code)) {
    throw new RuntimeException('Invalid JSON');
}

$address = new Address($street, $zip_code);
$user = new User($name, $age, $address);</code></pre>
<p>Into this:</p>
<pre><code class="language-php">&lt;?php declare(strict_types=1);
use Burba\StrictJson\StrictJson;
use Burba\StrictJson\Fixtures\Docs\User;

$mapper = new StrictJson();
$user = $mapper-&gt;map($json, User::class);</code></pre>
<h1 id="how-does-it-work">How does it work?</h1>
<p>StrictJson works with plain old php classes, they need to have a constructor with parameter names and types that match
your expected JSON, like this:</p>
<pre><code class="language-php">&lt;?php declare(strict_types=1);
use Burba\StrictJson\Fixtures\Docs\Address;

class User
{
    public function __construct(string $name, int $age, Address $address)
    {
        $this-&gt;name = $name;
        $this-&gt;age = $age;
        $this-&gt;address = $address;
    }
    /** Properties and getters omitted for brevity */
}</code></pre>
<p>StrictJson then examines the constructor of your model class and collects parameter names and types.
Then it validates the JSON to ensure that it has a property with a matching name and type for each required constructor
parameter. Finally, it instantiates your model classes (with their own constructor) and returns them to you.</p>
<h1 id="install">Install</h1>
<pre><code class="language-bash">composer require sburba/strict-json</code></pre>
<h1 id="optional-fields">Optional Fields</h1>
<p>If your constructor parameter has a default value, StrictJson will use that value if the field does not exist in the
JSON.</p>
<p>Here's a minimal example:</p>
<pre><code class="language-php">&lt;?php declare(strict_types=1);
use Burba\StrictJson\StrictJson;

class ModelWithOptionalParam
{
    private $optional_param;

    public function __construct(string $optional_param = 'default')
    {
        $this-&gt;optional_param = $optional_param;
    }

    /** Getters omitted for brevity */
}

$mapper = new StrictJson();
$model = $mapper-&gt;map('{}', ModelWithOptionalParam::class);
echo $model-&gt;getOptionalParam();
// Prints 'default'</code></pre>
<h1 id="nullable-fields">Nullable Fields</h1>
<p>If your constructor parameter has a nullable type, StrictJson will allow the JSON fields to be null as well.
Here's a minimal example:</p>
<pre><code class="language-php">&lt;?php declare(strict_types=1);
use Burba\StrictJson\StrictJson;

class ModelWithNullableParam
{
    private $nullable_param;

    public function __construct(?string $nullable_param)
    {
        $this-&gt;nullable_param = $nullable_param;
    }

    /** Getters omitted for brevity */
}

$json = '{"nullable_param": null}';

$mapper = new StrictJson();
$model = $mapper-&gt;map($json, ModelWithNullableParam::class);
$message = is_null($model-&gt;getNullableParam()) ? 'Param is null' : 'Param is not null';
echo $message;
// Prints 'Param is null'</code></pre>
<h1 id="custom-mapping">Custom Mapping</h1>
<p>To customize how StrictJson turns JSON into your models, create a class that implements <code>Burba\StrictJson\Adapter</code> and
register it for a class or parameter when creating StrictJson. See below for examples of the different types of
adapters.</p>
<h2 id="class-adapters">Class Adapters</h2>
<p>Sometimes your model classes have a parameter that does not have the same basic type as its JSON representation. In that
case, you can write a custom adapter to tell StrictJson how to parse that parameter.</p>
<p>For example, if you want to create DateTime objects from ISO8601 formatted strings, you can create a custom class
adapter like this:</p>
<pre><code class="language-php">&lt;?php declare(strict_types=1);
use Burba\StrictJson\Adapter;
use Burba\StrictJson\Internal\ArrayAdapter;
use Burba\StrictJson\JsonFormatException;
use Burba\StrictJson\JsonPath;
use Burba\StrictJson\StrictJson;
use Burba\StrictJson\Type;

class DateAdapter implements Adapter
{
    /**
     * Convert decoded json into the specified type
     *
     * @param string $decoded_json This is guaranteed to be one of the types returned from fromTypes
     * @param StrictJson $delegate Use this if you want to delegate a portion of the decoding process to StrictJson
     * @param JsonPath $path Include it when you throw JsonFormatException or delegate to StrictJson for better error
     * messages
     *
     * @return DateTime
     * @throws JsonFormatException If the JSON is not in the format you expect
     *
     * @see ArrayAdapter For a more advanced example that uses delegation and paths
     */
    public function fromJson($decoded_json, StrictJson $delegate, JsonPath $path): DateTime
    {
        $date = DateTime::createFromFormat(DATE_ISO8601, $decoded_json);
        if ($date === false) {
            throw new JsonFormatException("Expected ISO8601 date, found $decoded_json", $path);
        }

        return $date;
    }

    /**
     * @return Type[]
     */
    public function fromTypes(): array
    {
        return [Type::string()];
    }
}</code></pre>
<p>And use it like this:</p>
<pre><code class="language-php">&lt;?php declare(strict_types=1);
use Burba\StrictJson\Fixtures\Docs\DateAdapter;
use Burba\StrictJson\StrictJson;

class Event
{
    /** @var string */
    private $name;
    /** @var DateTime */
    private $date;

    public function __construct(string $name, DateTime $date)
    {
        $this-&gt;name = $name;
        $this-&gt;date = $date;
    }

    /** Getters omitted for brevity */
}

$json = '
{
    "name": "Dinner party for Bob",
    "date": "2013-02-13T08:35:34Z"
}
';

// Register your adapter
$mapper = StrictJson::builder()-&gt;addClassAdapter(DateTime::class, new DateAdapter())-&gt;build();
$event = $mapper-&gt;map($json, DateTime::class);

echo $event-&gt;getDate()-&gt;format("y");
// Prints "2013"</code></pre>
<h2 id="parameter-adapters">Parameter Adapters</h2>
<p>If you only want to map a single parameter of a class, you can use a parameter adapter:</p>
<pre><code class="language-php">&lt;?php declare(strict_types=1);
use Burba\StrictJson\Adapter;
use Burba\StrictJson\Fixtures\Docs\Event;
use Burba\StrictJson\JsonPath;
use Burba\StrictJson\StrictJson;
use Burba\StrictJson\Type;
use Burba\StrictJson\Fixtures\Docs\DateAdapter;

// Create your adapter as normal
class LenientBooleanAdapter implements Adapter
{
    public function fromJson($decoded_value, StrictJson $delegate, JsonPath $path): bool
    {
        return (bool)$decoded_value;
    }

    /** @return Type[] */
    public function fromTypes(): array
    {
        return [
            Type::int(),
            Type::bool(),
        ];
    }
}

$json = '
{
    "name": "Dinner party for Bob",
    "date": "2013-02-13T08:35:34Z",
    "is_suit_required": 1
}
';

$mapper = StrictJson::builder()
    -&gt;addClassAdapter(DateTime::class, new DateAdapter())
    // Register it as a parameter adapter
    -&gt;addParameterAdapter(Event::class, 'is_suit_required', new LenientBooleanAdapter())
    -&gt;build();

/** @var Event $event */
$event = $mapper-&gt;map($json, Event::class);
echo $event-&gt;isSuitRequired() ? 'Suit up' : 'Wear something casual';
// Prints "Suit up"</code></pre>
<h2 id="array-parameter-adapters">Array Parameter Adapters</h2>
<p>If your class contains arrays, you'll need to tell StrictJson the expected array item type, so that it can instantiate
those for you as well.</p>
<pre><code class="language-php">&lt;?php declare(strict_types=1);
use Burba\StrictJson\Fixtures\Docs\Address;
use Burba\StrictJson\Fixtures\Docs\Event;
use Burba\StrictJson\StrictJson;
use Burba\StrictJson\Fixtures\Docs\DateAdapter;
use Burba\StrictJson\Type;

// User class with array of events
class User
{
    /** @var string */
    private $name;
    /** @var int */
    private $age;
    /** @var Address */
    private $address;
    /** @var Event[] */
    private $events_attended;

    public function __construct(string $name, int $age, Address $address, array $events_attended = [])
    {
        $this-&gt;name = $name;
        $this-&gt;age = $age;
        $this-&gt;address = $address;
        $this-&gt;events_attended = $events_attended;
    }

    /** Getters omitted for brevity */
}

$json = '
{
    "name": "Tim Fabulous",
    "age": 40,
    "address": {
        "street": "1234 Fake St.",
        "zip_code": "12345"
    },
    "events_attended": [
        {
            "name": "Dinner party for Bob",
            "date": "2013-02-13T08:35:34Z"
        }
    ]
}
';

$mapper = StrictJson::builder()
    -&gt;addClassAdapter(DateTime::class, new DateAdapter())
    // Tell the mapper the events_attended parameter in the User class is an array of Events
    -&gt;addParameterArrayAdapter(User::class, 'events_attended', Event::class)
    -&gt;build();

$user = $mapper-&gt;map($json, User::class);
echo $user-&gt;getEventsAttended()[0]-&gt;getName();
// Prints "Dinner party for Bob"</code></pre>
<h1 id="custom-validation">Custom Validation</h1>
<p>If you want to validate more than just the parameter name and type of fields in the JSON, you can add a custom Adapter
that does the validation, or you can just validate in the constructor of your model class. Exceptions of type
<code>InvalidArgumentException</code> will be re-thrown wrapped in <code>JsonFormatException</code>, so that you just have one exception to
catch for validation errors. Other exceptions will be re-thrown wrapped in InvalidConfigurationException, to give you
the JSON parsing context.</p>
<h1 id="exceptions">Exceptions</h1>
<h2 id="jsonformatexception">JsonFormatException</h2>
<p>If the JSON is invalid, is missing required fields specified by your model constructor, or has fields which don't match
the types of your model constructor, StrictJson will throw a <code>JsonFormatException</code>, to indicate that the JSON was not
formatted as you expected. <code>JsonFormatException</code> messages will also include a full path to the place in the JSON that
is causing the error, which looks like this (if expecting an <code>int</code> array in position <code>$.a.b</code>):</p>
<p>JSON:</p>
<pre><code class="language-json">{
  "a": {
    "b": [1, "two", 3]
  }
}</code></pre>
<p>Error:</p>
<pre><code>Value is of type string, expected type int at path $.a.b[1]</code></pre>
<h2 id="invalidconfigurationexception">InvalidConfigurationException</h2>
<p>If StrictJson is configured incorrectly, for example, by mapping to a class that doesn't have a constructor, it will
throw <code>InvalidConfigurationException</code>. StrictJson does not validate adapters until it actually uses them for
performance reasons, so InvalidConfigurationException may be thrown later than you expect.</p>
<h1 id="migrating-from-v1">Migrating from V1</h1>
<ul>
<li>Your adapters now must implement <code>Burba\StrictJson\Adapter</code>.</li>
<li>The deprecated <code>StrictJson::mapParsed</code> has been removed. Use <code>StrictJson::mapDecoded</code> instead.</li>
<li>The <code>$target_type</code> argument in <code>StrictJson::mapDecoded</code> now must be of type <code>Burba\StrictJson\Type</code> instead of string</li>
<li>The <code>$context</code> argument in <code>StrictJson::mapDecoded</code> is now required</li>
<li>When specifying basic types using the array <code>$array_item_type</code> parameter in
<code>StrictJsonBuilder::addParameterArrayAdapter</code>, you must use the new <code>Burba\StrictJson\Type</code> class</li>
</ul>
<h1 id="migrating-from-v2">Migrating from V2</h1>
<ul>
<li>If you were using the parameter_adapters parameter in the StrictJson constructor, you'll have to migrate to using
<code>StrictJson::builder()</code></li>
<li>JsonContext has been renamed to JsonPath</li>
</ul>
<!-- CONTENT END -->

            </article>
            <aside class="sidebar">
                <hr>
                <div class="bulletlink"><a href="https://github.com/sburba/strict-json">GitHub</a></div>
                <div class="bulletlink"><a href="https://packagist.org/packages/sburba/strict-json">Packagist</a></div>
            </aside>
        </main>

        <script src="https://sburba.github.io/strict-json/assets/toc.js"></script>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/prism.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/plugins/autoloader/prism-autoloader.min.js"></script>
        <script>Prism.plugins.autoloader.languages_path = "https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/";</script>
        <link rel="stylesheet" href="https://sburba.github.io/strict-json/assets/prism.css">

    </body>
</html>
